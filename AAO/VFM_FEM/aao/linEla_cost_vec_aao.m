function [cost_vec, dcost_vec_dutheta] = linEla_cost_vec_aao(theta,u,reaction,u_global,mesh,lambda_r,lambda_d,varargin)

% default values
default_use_mex = false;
default_norm_type = 'I';
default_derivative_type = 'OFF';

% input parser
p = inputParser;
addOptional(p,'use_mex',default_use_mex);
addOptional(p,'norm_type',default_norm_type);
addOptional(p,'derivative_type',default_derivative_type);
parse(p,varargin{:});

%% Displacement
% u_global is the measured displacement
% u_measured is the measured displacement at the degrees of
% freedom, where the displacement is to be computed
u_measured = u_global(mesh.dof_unknown);

% u is the current guess of the displacement at the degrees of
% freedom, where the displacement is to be computed
% u_global_guess is the current guess of the displacement at all degrees of
% freedom
u_global_guess = u_global;
u_global_guess(mesh.dof_unknown) = u;

%% System Matrices and Vectors
if ~ p.Results.use_mex
    [K_Dirichlet, b_Dirichlet] = linEla_assemble_K_b_Dirichlet(theta,u_global,mesh,lambda_r);
else
    [K_Dirichlet, b_Dirichlet] = linEla_assemble_K_b_Dirichlet_mex_mex( ...
        theta, ...
        u_global, ...
        mesh.n_dof, ...
        mesh.n_element, ...
        mesh.element_dof, ...
        mesh.n_dof_per_element, ...
        mesh.n_Gauss_per_dim, ...
        mesh.detJ_GP, ...
        mesh.B_GP, ...
        mesh.Gauss_weights, ...
        mesh.dof_free, ...
        mesh.n_reaction, ...
        mesh.dof_reaction, ...
        mesh.dof_known, ...
        mesh.dof_unknown, ...
        lambda_r ...
        );
end
b_Neumann = assemble_b(reaction,mesh,lambda_r);
b = b_Dirichlet + b_Neumann;

%% Norm Kernel
if strcmp(p.Results.norm_type,'I')
    kern = eye(length(u));
elseif strcmp(p.Results.norm_type,'K')
    kern = K_Dirichlet;
end

%% Compute Cost
cost_vec = [(K_Dirichlet*u - b); sqrt(lambda_d) * (kern*(u-u_measured))];

%% Compute Derivative
if strcmp(p.Results.derivative_type,'OFF')
    dcost_vec_dutheta = zeros(length(cost_vec),length(theta)+length(u));
elseif strcmp(p.Results.derivative_type,'ANA')
    if ~ p.Results.use_mex
        A = linEla_assemble_A(u_global_guess,mesh,lambda_r);
    else
        A = linEla_assemble_A_mex_mex( ...
            u_global_guess, ...
            mesh.n_dof, ...
            mesh.n_element, ...
            mesh.element_dof, ...
            mesh.n_dof_per_element, ...
            mesh.n_Gauss_per_dim, ...
            mesh.detJ_GP, ...
            mesh.B_GP, ...
            mesh.Gauss_weights, ...
            mesh.dof_free, ...
            mesh.n_reaction, ...
            mesh.dof_reaction, ...
            lambda_r ...
            );
    end
    if strcmp(p.Results.norm_type,'I')
        A_kern = zeros(length(u_measured),size(A,2));
    elseif strcmp(p.Results.norm_type,'K')
        if ~ p.Results.use_mex
            A_kern = linEla_assemble_A((u_global_guess-u_global),mesh,lambda_r);
        else
            A_kern = linEla_assemble_A_mex_mex( ...
                (u_global_guess-u_global), ...
                mesh.n_dof, ...
                mesh.n_element, ...
                mesh.element_dof, ...
                mesh.n_dof_per_element, ...
                mesh.n_Gauss_per_dim, ...
                mesh.detJ_GP, ...
                mesh.B_GP, ...
                mesh.Gauss_weights, ...
                mesh.dof_free, ...
                mesh.n_reaction, ...
                mesh.dof_reaction, ...
                lambda_r ...
                );
        end
    end
    dcost_vec_dtheta = [A; sqrt(lambda_d) * A_kern];
    dcost_vec_du = [K_Dirichlet; sqrt(lambda_d) * kern];
    dcost_vec_dutheta = [dcost_vec_dtheta, dcost_vec_du];
    
    % alternative formula for the cost:
%     if strcmp(p.Results.norm_type,'I')
%         cost_vec_alt = [(A*theta - b_Neumann); sqrt(lambda_d) * (kern*(u-u_measured))];
%     elseif strcmp(p.Results.norm_type,'K')
%         cost_vec_alt = [(A*theta - b_Neumann); sqrt(lambda_d) * A_kern*theta];
%     end
    
elseif strcmp(p.Results.derivative_type,'FD')
    D = 1e-4;
    dcost_vec_dtheta = zeros(length(cost_vec),length(theta));
    for idx = 1:length(theta)
        theta_plus = theta; theta_plus(idx) = theta_plus(idx) + D;
        theta_minus = theta; theta_minus(idx) = theta_minus(idx) - D;
        cost_vec_plus = linEla_cost_vec_aao(theta_plus,u,reaction,u_global,mesh,lambda_r,lambda_d, ...
            'norm_type',p.Results.norm_type);
        cost_vec_minus = linEla_cost_vec_aao(theta_minus,u,reaction,u_global,mesh,lambda_r,lambda_d, ...
            'norm_type',p.Results.norm_type);
        dcost_vec_dtheta(:,idx) = (cost_vec_plus-cost_vec_minus) / (2*D);
    end
    dcost_vec_du = zeros(length(cost_vec),length(u));
    disp('Caution: Not all columns of the derivative are computed to save computational costs!')
    for idx = 1:5 % length(u) % !!!!!
        u_plus = u; u_plus(idx) = u_plus(idx) + D;
        u_minus = u; u_minus(idx) = u_minus(idx) - D;
        cost_vec_plus = linEla_cost_vec_aao(theta,u_plus,reaction,u_global,mesh,lambda_r,lambda_d, ...
            'norm_type',p.Results.norm_type);
        cost_vec_minus = linEla_cost_vec_aao(theta,u_minus,reaction,u_global,mesh,lambda_r,lambda_d, ...
            'norm_type',p.Results.norm_type);
        dcost_vec_du(:,idx) = (cost_vec_plus-cost_vec_minus) / (2*D);
    end
    dcost_vec_dutheta = [dcost_vec_dtheta, dcost_vec_du];
end

end













